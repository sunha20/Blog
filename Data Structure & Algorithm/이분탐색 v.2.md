---
Date: 2024-10-28
BackLink: "[[Algorithm & Data Structure|Algorithm & Data Structure]]"
---
### 개요
**정렬된 배열**에서 원하는 값을 빠르게 찾을 수 있는 탐색 기법으로, **탐색 범위를 절반씩 줄여가며 원하는 값을 찾아가는 방식**이다.


### 동작 방식 
1. 정렬된 배열에서 중간 값을 기준으로 `target` 값과 비교한다. 
2. `target`이 중간 값보다 크면 왼쪽 부분을 버리고, 작으면 오른쪽 부분을 버린다. 
3. 이 과정을 반복하면서 배열의 범위를 점점 좁혀 `target`을 찾는다.


### 시간복잡도
이분 탐색의 시간복잡도는 **O(log N)** 이다.

탐색의 범위를 절반씩 줄여나가며 탐색을 진행하는 방식으로, 매 실행마다 탐색범위가 절반씩 줄어들게 된다. 따라서 시간 복잡도는 배열 길이 N이 몇 번까지 2로 나누어(나머지 버림)질 수 있는가가 시간복잡도의 기준이 된다. 즉, $$ N  = 2^k  $$$$  k = \log_{2}N$$$$\therefore O(\log N)$$
으로 시간 복잡도는 O(log N)의 값을 가진다.


### 기본 이분 탐색 (정확한 값 찾기)
- (다양한 구현 방법 중, 내가 익숙한 한가지를 가지고 설명하겠다 → 이후에 등장하는 코드도 정답코드가 아닌 구현 방법중 하나일뿐이다.)
```python
lst = {0,10,20,30,40,50,60,70,80,90};  
t = 10;  
while lo <= hi:  
    mid = (lo + hi) // 2  
    if lst[mid] == t:  
        print(1)  
        break  
    else:  
        if lst[mid] < t: lo = mid + 1  
        else: hi = mid - 1  
else:  
    print(0)
```
- `while lo <= hi` → `lo`와 `hi`가 서로 반전되는 순간(`lo > hi`) `while`문 종료
	- target 값이 존재 할 수도 안 할 수도 있으니, 최대한 끝까지(탐색 구간이 아예 없을 때까지) 탐색하기 위해 이러한 종료 조건을 사용한다.
	- 즉, 종료 조건인 `lo > hi`의 의미는 **더이상 탐색할 구간이 없으니 그만하고 나가라**는 뜻이다.

- `lo`와 `hi`가 의미하는 건 다음과 같다.
	-  ![|260](그림2.png)
	- 탐색해야하는 **양극단의 요소**들을 참조한다는 느낌임

- `lo`를 `mid + 1`로 , `hi`를 `mid - 1`로 업데이트 하는 이유
	- 목적이 **정확한 값을 찾는 것**이기 때문에 `mid`는 이미 탐색한 idx이므로 다시 탐색할 필요가 없다
	- 따라서 `mid`를 제외한 범위를 책정하는 것이 효율적이다.

### OOO Bound
- 개요
	- 기본 이분탐색이 내가 이미 가지고 있는 책을 책장 안에서 찾아내는 느낌임
		- 따라서
	- OOO Bound는 책장에 새 책을 끼워넣을 올바른 위치를 찾는 느낌임
		- “찾는 값 **이상**의 값이 처음 등장하는 **위치**" 또는
		- "찾는 값을 **초과**하는 값이 처음 등장하는 **위치**"

-  `lo`와 `hi`의 초기값
	- 만일 찾는 값 이상(초과)의 값이 배열 내에 저장되어있지 않다면, 즉 배열 내의 값이 target값보다 다 작다면, **배열의 가장 마지막**이 해당 위치가 됨.
	- ![|290](그림1%201.png)
	- 따라서, `lo`는 일반적인 이분탐색과 같이 `0`으로 초기화 하지만, `hi`는 `len(arr)-1`이 아닌 `len(arr)`으로 초기화 한다.
	- 위 그림에서 10이 들어가는 위치까지 탐색할 수 있도록.

- 종료조건: `while lo < hi` → `lo`와 `hi`가 같아지는 순간(`lo == hi`) `while`문 종료
	- 기본 이분탐색과 달리 답이 반드시 있다.
		- 해당 값이 아니라, 끼워 넣을 위치를 찾는 것이기 때문이다.
		- 따라서 탐색을 하다 두 값이 같아진 곳(`lo == hi`)이 곧 답이된다.
	- 또한 index 값(`lo`, `hi`)이 우리가 원하는 값이기 때문에 둘의 인덱스가 반전될 때까지 탐색을 이어가면 마지막에 보정을 해줘야하는 귀찮음이 있다.
	- 종료조건인 `lo == hi`는 **우리가 찾는 위치에 결국 도달했고, 이게 정답!** 이라는 뜻이다.

#### Upper Bound
```python
lst = {0,10,20,30,40,50,60,70,80,90};  
t = 10.5;  
lo = 0
hi = len(lst)
while lo < hi:  
    mid = (lo + hi) // 2  
    now =  lst[mid]
    if now <=  t: lo = mid + 1
    if now > t: hi = mid 
```
- target **초과**인 값이 처음 등장하는 인덱스

- target 값과 마주쳤을 때
	- target 값을 찾았다고 바로 `return`되는 알고리즘이 아니기 때문에, target 값을 만났을 때 `lo`, `hi` 중 어떤 포인터를 옮길지가 중요하다.
	- upper bound의 경우, target값을 만났을 때 해당 위치의 **오른쪽에 또다른 target값이 존재**하는지 안하는지가 중요하다.
	- 따라서 오른쪽을 계속 탐색할 수 있도록, 왼쪽의 `lo`를 옮겨주는 것이 적절하다.

- `lo`를 `mid + 1`로 , `hi`를 `mid`로 업데이트 하는 이유
	- 우선 upper bound는 **범위를 계속 위쪽으로(오른쪽으로) 좁혀가야한다는 느낌**을 가지고 출발하자
	- `lo`
		- `mid`의 값 < target일 때 → `mid`까지는 target 값이 등장조차하지 않았으니, `mid`는 절대 우리가 찾는 위치가 아님.
		- `mid`의 값 == target일 때
			- 만일 뒤에도 target값이 있다면, 탐색을 계속하면 됨
			- 만일 `mid`의 값이 마지막 target값이었다면, 새로 업데이트 한 `lo`값이 우리가 찾는 위치가 될 것
	- `hi`: 
		- `mid`의 값 > target인 경우, 혹여나 해당 **`mid`의 값이 우리가 찾는 값**(target 이상인 첫 번째 값)일 수도 있음
		- `mid`를 포함하여 탐색할 수 있도록 `hi`를 `mid`로 업데이트 함.


#### Lower Bound
```python
lst = {0,10,20,30,40,50,60,70,80,90};  
t = 10.5;  
lo = 0
hi = len(lst)
while lo < hi:  
    mid = (lo + hi) // 2  
    now =  lst[mid]
    if now < t: lo = mid + 1
    if now >= t: hi = mid
```
- target **이상**인 값이 처음 등장하는 인덱스 = target 값이 처음 등장하는 인덱스

- target 값과 마주쳤을 때
	- 이것도 target 값을 찾았다고 바로 `return`되는 알고리즘이 아니기 때문에, target 값을 만났을 때 `lo`, `hi` 중 어떤 포인터를 옮길지가 중요하다.
	- lower bound의 경우, target값을 만났을 때 해당 위치의 **왼쪽에 또다른 target값이 존재**하는지 안하는지가 중요하다.
	- 따라서 왼쪽을 계속 탐색할 수 있도록, 오른쪽의 `hi`를 옮기는 것이 적절하다.

- `lo`를 `mid + 1`로 , `hi`를 `mid`로 업데이트 하는 이유
	- 우선 lower bound는 범위를 계속 아래쪽으로(왼쪽으로) 좁혀가야한다는 느낌을 가지고 출발하자
	- `lo`
		- `mid`의 값 < target일 때 → `mid`까지는 target 값이 등장조차하지 않았으니, `mid`는 절대 우리가 찾는 위치가 아님.
	- `hi`: 
		- `mid`의 값 ≥ target인 경우, 혹여나 해당 **`mid`의 값이 우리가 찾는 값**(target 이상인 첫 번째 값)일 수도 있음
		- `mid`를 포함하여 탐색할 수 있도록 `hi`를 `mid`로 업데이트 함.
